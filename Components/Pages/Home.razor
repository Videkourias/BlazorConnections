@page "/"
@inject INYTService _nytService

<PageTitle>BlazorConnections</PageTitle>

<MudPaper Height="85vh" Elevation="0">
    <MudContainer Class="pt-2">
        <MudContainer Class="d-flex gap-4 align-center">
            <MudText Class="title">Connections</MudText>
            <MudDatePicker Label="Game Date" @bind-Date="ConnectionDate" @bind-Date:after="ConnectionDateUpdate" IsDateDisabledFunc="@((DateTime dt)=>(dt < new DateTime(2023, 6, 12) || DateOnly.FromDateTime(dt) > DateOnly.FromDateTime(DateTime.Now.AddDays(1))))"/>
        </MudContainer>
    </MudContainer>
    <MudDivider DividerType="DividerType.Middle" Class="my-6"/>
    <MudContainer Class="d-flex flex-row justify-center align-start" Style="height: 60%"> 
        @if(Connection is not null) 
        {
                @if(Connection.HasWon)
                {
                    <MudText Typo="Typo.h1">You won!</MudText>
                    <MudText Typo="Typo.h1">Congratulations!</MudText>
                }
                else if(Connection.Chances == 0)
                {
                    <MudText Typo="Typo.h1">You lost!</MudText>
                }
                else
                {            
                    <MudStack>
                        <MudContainer Class="d-flex justify-center align-center">
                            <h2>Create four groups of four!</h2>
                        </MudContainer>   
                        <MudGrid Spacing="3">
                            <MudPopover OverflowBehavior="OverflowBehavior.FlipNever" Open="@PopoverHints["AlreadyGuessed"]" AnchorOrigin="Origin.CenterCenter" TransformOrigin="Origin.TopCenter" Class="pa-2 popoverHint" Square="false" DropShadow="false">
                                <p>Already guessed!</p>
                            </MudPopover>
                            <MudPopover OverflowBehavior="OverflowBehavior.FlipNever" Open="@PopoverHints["Incorrect"]" AnchorOrigin="Origin.CenterCenter" TransformOrigin="Origin.TopCenter" Class="pa-2 popoverHint" Square="false" DropShadow="false"> 
                                <p>Incorrect!</p>
                            </MudPopover>
                            <MudPopover OverflowBehavior="OverflowBehavior.FlipNever" Open="@PopoverHints["OneOff"]" AnchorOrigin="Origin.CenterCenter" TransformOrigin="Origin.TopCenter" Class="pa-2 popoverHint" Square="false" DropShadow="false">
                                <p>One Off!</p>
                            </MudPopover>

                            
                            @foreach(var wordGroup in Connection.Groups.Where(x => x.Completed).OrderBy(x => x.TimeCompleted)) //Display already completed groups
                            {
                                string style = "background-color: " + wordGroup.Difficulty switch
                                {
                                    Difficulty.Yellow => "rgb(249, 223, 109)",
                                    Difficulty.Green => "rgb(160, 195, 90)",   
                                    Difficulty.Blue => "rgb(176, 196, 239)",
                                    Difficulty.Purple => "rgb(186, 129, 197)",
                                    _ => ""
                                };
                                <MudItem xs="12" Style="height: 8em">
                                    <MudPaper Elevation="0" Class="rounded pa-4 d-flex justify-center align-center wordCard" Style=@style>
                                        <MudStack Spacing="0" AlignItems="AlignItems.Center">
                                            <MudText Class="correctWordCategory nytArial">@wordGroup.GroupName</MudText>
                                            <MudStack Row Justify="Justify.Center" Spacing="1">
                                                @{
                                                    var lastWord = wordGroup.Words.Last();
                                                } 
                                                @foreach(var word in wordGroup.Words)
                                                {
                                                    <MudText Class="correctWord nytArial" Style="">@word.Value@(word.Equals(lastWord) ? "" : ",")</MudText>
                                                }
                                            </MudStack>
                                        </MudStack>
                                    </MudPaper>
                                </MudItem>
                            }
                        
                            @foreach(var word in Connection.WordList) //Display non-matched words
                            {
                                string paperClass = "rounded pa-4 d-flex justify-center align-center wordCard" 
                                                        + (Connection.FourWordsSelected ? (word.IsSelected ? " cursor-pointer" : "") : " cursor-pointer") //Determine if word has pointer cursor on hover
                                                        + (word.IsSelected ? " selected" : ""); //Determine if word has selected stylings

                                <MudItem xs="3" Style="height: 8em">
                                    <MudPaper Elevation="0" Class="@paperClass" @onclick="() => SelectWord(word.Value)">
                                        <MudText Class="noSelect wordCardText nytArial">@word.Value</MudText>
                                    </MudPaper>
                                </MudItem>
                            }
                            
                        </MudGrid>  
                        <MudContainer Class="d-flex flex-row justify-center align-end gap-1">
                        <MudText>Mistakes Remaining: </MudText>
                        @for(int i = 0; i < Connection.Chances; i++)
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Circle" Color="Color.Dark" Size="Size.Small"></MudIcon>
                        }
                        </MudContainer>
                        <MudContainer Class="d-flex flex-row justify-center align-start gap-2">
                            <MudButton Variant="Variant.Outlined" Class="rounded-pill mud-border-black" OnClick="Shuffle">Shuffle</MudButton>
                            <MudButton Variant="Variant.Outlined" Class="rounded-pill" OnClick="DeselectAll">Deselect All</MudButton>
                            <MudButton Variant="Variant.Filled" Class="rounded-pill" Disabled="!Connection.FourWordsSelected || DisableSubmit" OnClick="Submit">Submit</MudButton>
                        </MudContainer>  
                    </MudStack>
                }
                
        }
        else
        {
            <MudText>Select a date to play!</MudText>
        }
    </MudContainer>
</MudPaper>

<style>
    .title{
        font-family: "nyt-karnakcondensed";
        font-size: 42px;
        font-weight: 700;
    }

    .wordCard{
        height: 100%;
        background-color: #efefe6;
        color: #121212; 
        transition: 0.2s all;
    }

    .wordCard.selected{
        background-color: #5a594e;
        color: #f8f8f8;
    }

    .wordCard .wordCardText{
        font-size: 20pt; 
        font-weight: 700;
        text-transform: uppercase;
    }


    .popoverHint{
        background-color: #1d1d1e;
        color: white;
    }

    .nytArial{
        font-family: "nyt-franklin", Arial;
    }

    .correctWord{
        font-weight: 500;
        font-size: 20px;
    }

    .correctWordCategory{
        font-weight: 700;
        font-size: 20px;
    }

    .noSelect {
        -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Safari */
        -khtml-user-select: none; /* Konqueror HTML */
        -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
         user-select: none; /* Non-prefixed version, currently
                                    supported by Chrome, Edge, Opera and Firefox */
    }
</style>

@code{

    private Connection Connection { get; set; }
    private DateTime? ConnectionDate { get; set; } = DateTime.Now;
    private bool DisableSubmit = false;
    
    
    private HashSet<string> AttemptedCombinations { get; set; } = new();
    private List<string> DifficultyGuesses { get; set; } = new();

    
    private Dictionary<string, bool> PopoverHints = new Dictionary<string, bool>
    {
        {"Incorrect", false},
        {"AlreadyGuessed", false},
        {"OneOff", false}
    };

    //May want to switch to non prerendering, this adds noticeable delay    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(!firstRender)
        {
            return;
        }

        await GetConnection();
        StateHasChanged();
    }

    private async Task GetConnection()
    {
        if(ConnectionDate is null)
        {
            return;
        }

        //Get game date from date picker, or default to today's date
        Connection = await _nytService.GetConnection(DateOnly.FromDateTime((DateTime)ConnectionDate));

        if(Connection == null)
        {
            //FailedToGetConnection = true;
            return;
        }
    }

    private void SelectWord(string word)
    {
        DisableSubmit = false; //Allow submission again
        
        var selectedWord = Connection.Groups.SelectMany(x => x.Words).FirstOrDefault(x => x.Value == word);

        if(selectedWord is null)
        {
            return;
        }

        //Don't allow selection if 4 or more words are already selected and not deselecting
        if(Connection.FourWordsSelected && !selectedWord.IsSelected)
        {
            return;
        }

        selectedWord.IsSelected = !selectedWord.IsSelected;

        StateHasChanged();
    }

    private void DeselectAll()
    {
        Connection.Groups.SelectMany(x => x.Words).ToList().ForEach(x => x.IsSelected = false);

        StateHasChanged();
    }

    private void Shuffle()
    {
        Connection.ShuffledWordList();
        StateHasChanged();
    }

    public void Submit()
    {
        DisableSubmit = true; //Prevent double submission

        var selectedWords = Connection.WordList.Where(x => x.IsSelected);

        string key = string.Join("", selectedWords.Select(x => x.Value).OrderByDescending(x => x)); //Unique key for word combination

        //Verify if words have already been guessed
        if(AttemptedCombinations.Contains(key))
        {
            //Show attempted warning
            FlashHint("AlreadyGuessed");
            return;
        }
        AttemptedCombinations.Add(key);

        //Check how many words are in each group
        Dictionary<int, int> counts = new Dictionary<int, int>
        {
            {0, 0},
            {1, 0},
            {2, 0},
            {3, 0}
        };

        //Get currently selected words
        foreach(var word in selectedWords)
        {
            int difficulty = (int)word.Difficulty;

            counts[difficulty]++;
        }



        bool oneOff = false;
        foreach(var kv in counts)
        {
            if(kv.Value == 4) //Successful guess, remove that word group from puzzle
            {
                Connection.MarkGroupComplete((Difficulty)kv.Key);
                StateHasChanged();
                return;
            }
            else if(kv.Value == 3) //One off, display hint
            {
                FlashHint("OneOff");
                oneOff = true;
            }
        }

        //Add list of words to store of guessed words + remove one from allowed mistakes
        if(!oneOff)
        {
            FlashHint("Incorrect");
        }
            
        Connection.Chances -= 1;

        StateHasChanged();
    }

    async void FlashHint(string hintKey)
    {
        PopoverHints[hintKey] = true;

        await Task.Delay(3000);

        PopoverHints[hintKey] = false;

        StateHasChanged();
    }
    

    async Task ConnectionDateUpdate()
    {
        await GetConnection();
        StateHasChanged();
    }
}